<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rusty Moose Stats Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <style>
    :root { --steam-bg: #0f1a24; --steam-panel: #0b141d; --steam-accent: #66c0f4; --text-primary: #e5f1ff; --text-secondary: #9bb6cc; --card-border: rgba(102, 192, 244, 0.25); }
    * { box-sizing: border-box; }
    body { font-family: "Segoe UI", Roboto, system-ui, -apple-system, sans-serif; background: radial-gradient(circle at 20% 20%, rgba(102,192,244,0.08), transparent 30%), radial-gradient(circle at 80% 0%, rgba(102,192,244,0.08), transparent 30%), var(--steam-bg); color: var(--text-primary); display: flex; flex-direction: column; align-items: center; min-height: 100vh; margin: 0; padding: 24px; }
    .panel { background: linear-gradient(135deg, rgba(20,33,44,0.8), rgba(12,20,28,0.95)); border: 1px solid var(--card-border); border-radius: 12px; padding: 20px; width: min(1700px, 98vw); box-shadow: 0 20px 50px rgba(0,0,0,0.45); }
    h1 { margin: 0 0 20px 0; font-weight: 700; letter-spacing: 0.5px; }
    .title-row {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .title-row h1 { margin: 0; }
    h2 { display: none; margin-bottom: 4px; }
    .btn-icon { background: rgba(255,255,255,0.08); color: var(--text-primary); border: 1px solid rgba(255,255,255,0.1); width: 62px; height: 62px; border-radius: 10px; font-weight: 800; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0; }
    .btn-icon.primary { background: var(--steam-accent); color: #04101a; border: none; }
    .player-card {
      position: relative;
      display: flex;
      align-items: stretch;
      gap: 12px;
      padding: 10px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 10px;
      flex: 1 1 auto;
      min-width: 0;
      width: 100%;
    }
    .player-card.expanded {
      flex-direction: column;
      align-items: stretch;
      z-index: 3;
    }
    .player-card:hover {
      box-shadow: 0 0 14px rgba(102, 192, 244, 0.18);
      border-color: rgba(102, 192, 244, 0.45);
    }
    .player-link {
      display: flex;
      align-items: center;
      gap: 12px;
      text-decoration: none;
      color: inherit;
      flex: 1 1 auto;
      min-width: 0;
    }
    .player-card.expanded .player-link {
      width: 100%;
    }
    .remove-btn { position: absolute; top: 6px; right: 6px; width: 22px; height: 22px; background: none; color: #fff; border: none; font-weight: 800; cursor: pointer; opacity: 0; transition: opacity 0.2s; }
    .avatar { width: 42px; height: 42px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.08); object-fit: cover; background: #091017; }
    .player-meta { display: flex; flex-direction: column; gap: 2px; }
    .player-name { font-weight: 600; color: var(--text-primary); }
    .player-missing { font-size: 11px; color: var(--text-secondary); letter-spacing: 0.2px; }
    .player-toggle {
      position: absolute;
      bottom: 6px;
      right: 6px;
      width: 22px;
      height: 22px;
      background: none;
      color: #fff;
      border: none;
      font-weight: 800;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .player-card:hover .remove-btn,
    .player-card:hover .player-toggle { opacity: 1; }
    .player-card.expanded .player-toggle { transform: rotate(180deg); }
    .player-panel {
      display: none;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.08);
      gap: 8px;
      flex-direction: column;
      width: 100%;
    }
    .player-card.expanded .player-panel { display: flex; }
    .player-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .player-field label {
      font-size: 11px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      color: var(--text-secondary);
    }
    .player-field input {
      background: rgba(255,255,255,0.06);
      color: var(--text-primary);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
    }
    .player-save {
      align-self: flex-start;
      background: rgba(102,192,244,0.2);
      color: var(--text-primary);
      border: 1px solid rgba(102,192,244,0.4);
      border-radius: 8px;
      padding: 6px 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .stat-details {
      margin-top: 16px;
      padding: 12px 14px;
      background: rgba(8, 13, 18, 0.6);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      width: min(720px, 100%);
      margin-left: auto;
      margin-right: auto;
    }

    .stat-details h3 {
      margin: 0 0 10px 0;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    .stat-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .stat-row {
      display: grid;
      grid-template-columns: 60px 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.05);
      font-size: 22px;
    }
    .stat-row.rank-1 {
      box-shadow: 0 0 18px rgba(212, 175, 55, 0.35);
      border-color: rgba(212, 175, 55, 0.4);
    }
    .stat-row.rank-2 {
      box-shadow: 0 0 16px rgba(192, 192, 192, 0.3);
      border-color: rgba(192, 192, 192, 0.4);
    }
    .stat-row.rank-3 {
      box-shadow: 0 0 16px rgba(205, 127, 50, 0.35);
      border-color: rgba(205, 127, 50, 0.4);
    }
    .stat-rank {
      font-weight: 800;
      text-align: left;
    }
    .stat-rank.medal {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      font-size: 14px;
      letter-spacing: 0.2px;
      text-align: center;
      box-shadow:
        inset 0 0 6px rgba(255,255,255,0.35),
        0 0 12px rgba(0,0,0,0.35);
    }
    .stat-rank.medal.rank-1 {
      background: radial-gradient(circle at 30% 30%, #fff2b5 0%, #e0b44d 35%, #b3831e 100%);
      text-shadow:
        0 1px 0 rgba(0,0,0,0.55),
        0 -1px 0 rgba(255,255,255,0.4),
        0 0 6px rgba(255, 226, 155, 0.45);
    }
    .stat-rank.medal.rank-2 {
      background: radial-gradient(circle at 30% 30%, #f3f3f3 0%, #c7c7c7 40%, #8f8f8f 100%);
      text-shadow:
        0 1px 0 rgba(0,0,0,0.6),
        0 -1px 0 rgba(255,255,255,0.4),
        0 0 6px rgba(230, 230, 230, 0.4);
    }
    .stat-rank.medal.rank-3 {
      background: radial-gradient(circle at 30% 30%, #ffd1a8 0%, #d28a4a 45%, #9a5a1c 100%);
      text-shadow:
        0 1px 0 rgba(0,0,0,0.6),
        0 -1px 0 rgba(255,255,255,0.4),
        0 0 6px rgba(255, 198, 140, 0.45);
    }
    .stat-name {
      text-align: center;
      font-weight: 600;
    }
    .stat-value {
      font-size: 28px;
      font-weight: 500;
    }

    .stat-header-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .stat-header-btn {
      position: absolute;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff;
      border-radius: 10px;
      padding: 8px 12px;
      font-weight: 800;
      font-size: 14px;
      cursor: pointer;
      transform: translateX(-50%);
      pointer-events: auto;
      white-space: nowrap;
    }

    .stat-header-btn:hover {
      box-shadow: 0 0 16px rgba(102, 192, 244, 0.35);
      border-color: rgba(102, 192, 244, 0.6);
    }
    .stat-header-btn.active {
      background: var(--steam-accent);
      color: #04101a;
      border-color: transparent;
    }
    .stats-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      width: 100%;
      margin-bottom: 2px; /* slightly tighter spacing above chart */
    }

    .server-control {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 200px;
      align-items: flex-end;
      margin-top: 2px;
    }

    .server-label {
      font-size: 11px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      color: var(--text-secondary);
    }

    .server-select {
      background: #0f1a24;
      color: var(--text-primary);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 8px 10px;
      font-weight: 600;
      cursor: pointer;
    }

    .server-select option {
      background: #0f1a24;
      color: var(--text-primary);
    }

    .stats-header__players {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      align-items: stretch;
      gap: 0.75rem;
      min-height: 62px;
    }

    .stats-chart-container {
      position: relative;
      width: 100%;
      min-height: 380px; /* base height */
      height: 48vh;
      max-height: 460px;
      margin-top: 0;  /* no extra gap below header */
      padding: 0;    /* ensure no extra spacing inside container */
      overflow: hidden;
    }

    canvas { width: 100% !important; height: 100% !important; display: block; }

    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(9, 16, 23, 0.6);
      backdrop-filter: blur(1px);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 9999;
    }

    .loading-overlay.show {
      opacity: 1;
      pointer-events: all;
    }

    .color-toggle {
      position: fixed;
      right: 18px;
      bottom: 18px;
      display: flex;
      gap: 6px;
      padding: 8px;
      background: rgba(8, 13, 18, 0.7);
      border: 1px solid rgba(102, 192, 244, 0.25);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      z-index: 9998;
    }

    .color-toggle button {
      background: rgba(255,255,255,0.08);
      color: var(--text-primary);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      padding: 6px 10px;
      font-weight: 700;
      font-size: 12px;
      cursor: pointer;
    }

    .color-toggle button.active {
      background: var(--steam-accent);
      color: #04101a;
      border-color: transparent;
    }

    .loading-box {
      background: rgba(12, 20, 28, 0.9);
      border: 1px solid rgba(102, 192, 244, 0.35);
      border-radius: 12px;
      padding: 16px 20px;
      color: var(--text-primary);
      font-weight: 700;
      letter-spacing: 0.3px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.4);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .loading-texts {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #loading-subtext {
      font-size: 12px;
      opacity: 0.8;
    }

    .loading-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--steam-accent);
      animation: pulse 0.9s ease-in-out infinite;
      box-shadow: 0 0 12px rgba(102,192,244,0.7);
    }

    @keyframes pulse {
      0%, 100% { transform: scale(0.9); opacity: 0.7; }
      50% { transform: scale(1.2); opacity: 1; }
    }
  </style>
</head>
  <body>
    <div id="loading-overlay" class="loading-overlay">
      <div class="loading-box">
        <div class="loading-dot"></div>
        <div class="loading-texts">
          <div id="loading-text">Loading...</div>
          <div id="loading-subtext"> </div>
        </div>
      </div>
    </div>
    <div class="panel">
      <div class="title-row">
        <h1 id="title">Rusty Moose Stats Chart</h1>
        <div class="server-control">
          <label class="server-label" for="serverSelect">Server</label>
          <select id="serverSelect" class="server-select">
            <option value="US Monthly (Premium)">US Monthly (Premium)</option>
            <option value="US Biweekly (Premium)">US Biweekly (Premium)</option>
          </select>
        </div>
      </div>
      <h2 id="subtitle"></h2>

    <div class="stats-header">
      <button id="refresh" class="btn-icon primary" title="Refresh">↻</button>
      <div class="stats-header__players" id="players"></div>
      <button id="add" class="btn-icon" title="Add player">+</button>
    </div>

    <div class="stats-chart-container">
      <div id="statHeaderOverlay" class="stat-header-overlay"></div>
      <canvas id="statsChart"></canvas>
    </div>
    <div id="statDetails" class="stat-details" style="display:none;">
      <h3 id="statDetailsTitle">Stat</h3>
      <div id="statDetailsList" class="stat-list"></div>
    </div>
  </div>
  <div id="colorModeToggle" class="color-toggle">
    <button type="button" data-mode="original">Original</button>
    <button type="button" data-mode="contrast">Contrast</button>
  </div>

  <script>
    const chartCtx = document.getElementById('statsChart').getContext('2d');
    let chart;
    let currentProfiles = [];
    const serverSelect = document.getElementById('serverSelect');
    const FALLBACK_AVATAR =
      'https://steamcommunity-a.akamaihd.net/public/shared/images/responsive/share_steam_logo.png';
    const colorToggle = document.getElementById('colorModeToggle');
    let colorMode = localStorage.getItem('mooseColorMode') || 'original';
    let lastData = null;
    let selectedMetric = null;
    let userSelectedMetric = false;

    function formatNumber(n) {
      const abs = Math.abs(n);
      if (abs >= 1e6) return (n / 1e6).toFixed(2).replace(/\.?0+$/, '') + 'm';
      if (abs >= 1e3) return (n / 1e3).toFixed(2).replace(/\.?0+$/, '') + 'k';
      return Number.isInteger(n) ? n.toString() : n.toFixed(2);
    }

    function ensureTooltipEl() {
      let el = document.getElementById('chartjs-external-tooltip');
      if (!el) {
        el = document.createElement('div');
        el.id = 'chartjs-external-tooltip';
        el.style.position = 'absolute';
        el.style.pointerEvents = 'none';
        el.style.zIndex = '9999';
        document.body.appendChild(el);
      }
      return el;
    }

    function updateTitle() {
      const titleEl = document.getElementById('title');
      if (titleEl) titleEl.textContent = 'Rusty Moose Stats Chart';
      document.title = 'Rusty Moose Stats Chart';
    }

    function hexToHsl(hex) {
      const clean = hex.replace('#', '');
      const expanded = clean.length === 3 ? clean.split('').map((c) => c + c).join('') : clean;
      const bigint = parseInt(expanded, 16);
      const r = ((bigint >> 16) & 255) / 255;
      const g = ((bigint >> 8) & 255) / 255;
      const b = (bigint & 255) / 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0;
      let s = 0;
      const l = (max + min) / 2;
      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h: h * 360, s: s * 100, l: l * 100 };
    }

    function hslToHex(h, s, l) {
      const sat = s / 100;
      const light = l / 100;
      const c = (1 - Math.abs(2 * light - 1)) * sat;
      const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
      const m = light - c / 2;
      let r = 0;
      let g = 0;
      let b = 0;
      if (h < 60) {
        r = c;
        g = x;
      } else if (h < 120) {
        r = x;
        g = c;
      } else if (h < 180) {
        g = c;
        b = x;
      } else if (h < 240) {
        g = x;
        b = c;
      } else if (h < 300) {
        r = x;
        b = c;
      } else {
        r = c;
        b = x;
      }
      const toHex = (val) => Math.round((val + m) * 255).toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function buildColorMap(profiles) {
      const map = {};
      if (colorMode === 'original') {
        profiles.forEach((p) => {
          const key = p.displayName || p.fallbackName;
          map[key] = p.color || '#66c0f4';
        });
        return map;
      }

      const usedHues = [];
      const hueDistance = (h1, h2) => {
        const diff = Math.abs(h1 - h2) % 360;
        return Math.min(diff, 360 - diff);
      };
      profiles.forEach((p, idx) => {
        const key = p.displayName || p.fallbackName;
        const base = p.color || '#66c0f4';
        const { h } = hexToHsl(base);
        let hue = h;
        let attempts = 0;
        while (usedHues.some((u) => hueDistance(u, hue) < 25) && attempts < 10) {
          hue = (hue + 137.5) % 360;
          attempts += 1;
        }
        usedHues.push(hue);
        const sat = 85;
        const light = 55;
        map[key] = hslToHex(hue, sat, light);
      });
      return map;
    }

    function renderStatDetails(metric, data, colorMap = {}) {
      const panel = document.getElementById('statDetails');
      const title = document.getElementById('statDetailsTitle');
      const list = document.getElementById('statDetailsList');
      if (!panel || !title || !list || !metric || !data) return;
      title.textContent = metric;
      const toOrdinal = (n) => {
        const mod100 = n % 100;
        if (mod100 >= 11 && mod100 <= 13) return `${n}th`;
        switch (n % 10) {
          case 1:
            return `${n}st`;
          case 2:
            return `${n}nd`;
          case 3:
            return `${n}rd`;
          default:
            return `${n}th`;
        }
      };
      const rows = (data.profiles || [])
        .map((p) => {
          const key = p.displayName || p.fallbackName;
          const raw = data.stats && data.stats[key] ? data.stats[key][metric] : 0;
          const value = metric === 'Headshot %' ? Math.round(raw) : raw;
          return { key, value, profile: p };
        })
        .sort((a, b) => b.value - a.value)
        .map((item, index) => {
          const color = colorMap[item.key] || item.profile.color || '#66c0f4';
          const rank = index + 1;
          const rankColor = rank === 1 ? '#8f6d12' : rank === 2 ? '#6f6f6f' : rank === 3 ? '#7a4718' : '#ffffff';
          const displayValue =
            metric === 'Headshot %' ? `${formatNumber(item.value ?? 0)}%` : formatNumber(item.value ?? 0);
          const medalClass = rank <= 3 ? `medal rank-${rank}` : '';
          return `
            <div class="stat-row rank-${rank}" style="border-left: 3px solid ${color};">
              <span class="stat-rank ${medalClass}" style="color:${rankColor}">${toOrdinal(rank)}</span>
              <span class="stat-name" style="color:${color}">${item.key}</span>
              <strong class="stat-value" style="color:${color}">${displayValue}</strong>
            </div>
          `;
        })
        .join('');
      list.innerHTML = rows;
      panel.style.display = 'block';
    }

    function renderStatHeaderButtons(chartInstance) {
      const container = document.getElementById('statHeaderOverlay');
      if (!container || !chartInstance || !lastData) return;
      const labels = chartInstance.data.labels || [];
      const xScale = chartInstance.scales?.x;
      const chartArea = chartInstance.chartArea;
      if (!xScale || !chartArea) return;
      const top = Math.max(6, chartArea.top - 42);
      container.innerHTML = labels
        .map((label, idx) => {
          const left = xScale.getPixelForTick(idx);
          return `
            <button type="button"
              class="stat-header-btn${label === selectedMetric ? ' active' : ''}"
              data-metric="${label}"
              style="left:${left}px; top:${top}px;">
              ${label}
            </button>
          `;
        })
        .join('');
      container.querySelectorAll('.stat-header-btn').forEach((btn) => {
        btn.addEventListener('click', () => {
          const metric = btn.getAttribute('data-metric');
          if (!metric || !lastData) return;
          selectedMetric = metric;
          userSelectedMetric = true;
          renderStatHeaderButtons(chartInstance);
          const colorMap = buildColorMap(lastData.profiles || []);
          renderStatDetails(metric, lastData, colorMap);
          chartInstance.update();
        });
      });
    }

    function applyRender(data) {
      const stats = data.stats || {};
      const missingItems = data.missing || [];
      const missingLabels = new Set(
        missingItems.map((item) => (item && item.label ? String(item.label) : '')).filter(Boolean)
      );
      const missingIds = new Set(
        missingItems
          .map((item) => (item && item.steamId ? String(item.steamId) : ''))
          .filter(Boolean)
      );
      const missingUrls = new Set(
        missingItems
          .map((item) => (item && item.steamUrl ? String(item.steamUrl) : ''))
          .filter(Boolean)
      );
      const normalizedProfiles = (data.profiles || []).map((p) => {
        const key = p.displayName || p.fallbackName;
        const hasStats = key && Object.prototype.hasOwnProperty.call(stats, key);
        const byLabel = key && missingLabels.has(String(key));
        const byId = p.steamId && missingIds.has(String(p.steamId));
        const byUrl = p.steamUrl && missingUrls.has(String(p.steamUrl));
        const isMissing = byLabel || byId || byUrl;
        return { ...p, missing: hasStats ? false : isMissing };
      });
      data.profiles = normalizedProfiles;
      const colorMap = buildColorMap(data.profiles || []);
      renderPlayers(data.profiles, colorMap);
      buildChart(data, colorMap);
      updateTitle();
      const missingCount = (data.missing || []).length;
      const missingNote = missingCount ? ` • Missing: ${missingCount}` : '';
      document.getElementById('subtitle').textContent =
        data.serverName + ' • ' + data.metrics.join(' • ') + missingNote;
      if (selectedMetric) renderStatDetails(selectedMetric, data, colorMap);
    }

    const externalTooltipHandler = (context) => {
      const { chart, tooltip } = context;
      const el = ensureTooltipEl();
      if (!tooltip || !tooltip.dataPoints || !tooltip.dataPoints.length) {
        el.style.opacity = '0';
        return;
      }
      const dp = tooltip.dataPoints[0];
      const dataset = chart.data.datasets[dp.datasetIndex];
      const value =
        (dataset.realValues && dataset.realValues[dp.dataIndex]) ??
        dp.parsed.y ??
        dp.raw ??
        0;
      const color = dataset.borderColor || '#66c0f4';
      const avatar = dataset.avatarUrl || '';

      el.innerHTML =
        '<div style="display:flex;align-items:center;gap:10px;padding:10px 12px;' +
        'background: rgba(12,16,24,0.95);' +
        'border: 1px solid rgba(102,192,244,0.35);' +
        'border-left: 3px solid ' + color + ';' +
        'border-radius: 10px;' +
        'box-shadow: 0 10px 30px rgba(0,0,0,0.4);' +
        'color: #cce7ff;' +
        'min-width: 180px;">' +
        '<img src="' + avatar + '" alt="' + dataset.label + ' avatar" style="' +
        'width:38px;height:38px;border-radius:6px;' +
        'border:1px solid rgba(255,255,255,0.1);object-fit:cover;' +
        'background:#0b141d;" />' +
        '<div style="display:flex;flex-direction:column;line-height:1.2;">' +
        '<div style="font-size:11px;font-weight:600;color:#cce7ff;opacity:0.85;">' +
        dataset.label +
        '</div>' +
        '<div style="font-size:12px;font-weight:600;color:#cce7ff;">' +
        dp.label + ':' +
        '</div>' +
        '<div style="font-size:18px;font-weight:800;color:' + color + ';">' +
        formatNumber(value) +
        '</div>' +
        '</div>' +
        '</div>';

      const canvasRect = chart.canvas.getBoundingClientRect();
      const positionX = canvasRect.left + window.pageXOffset;
      const positionY = canvasRect.top + window.pageYOffset;
      el.style.opacity = '1';
      el.style.left = positionX + tooltip.caretX + 10 + 'px';
      el.style.top = positionY + tooltip.caretY + 10 + 'px';
    };

    function buildChart(data, colorMap = {}) {
      const { metrics, profiles, stats } = data;
      const activeProfiles = (profiles || []).filter((p) => {
        const key = p.displayName || p.fallbackName;
        return key && Object.prototype.hasOwnProperty.call(stats, key);
      });
      currentProfiles = activeProfiles;
      let maxValue = 0;
      const headroomFactor = 2.6; // extra headroom for labels
      const labelPaddingTop = 56; // internal top padding for labels + header buttons
      const playerCount = activeProfiles.length;
      const barScale = Math.max(0.3, 0.85 - playerCount * 0.04);
      const datasets = activeProfiles.map((p) => {
        const playerStats = stats[p.displayName || p.fallbackName];
        const realValues = metrics.map((m) => {
          const raw = playerStats[m] ?? 0;
          return m === 'Headshot %' ? Math.round(raw) : raw;
        });
        const dataValues = realValues.map((v) => (v > 0 ? v : 0.1));
        realValues.forEach((v) => {
          if (typeof v === 'number' && v > maxValue) maxValue = v;
        });
        const key = p.displayName || p.fallbackName;
        const color = colorMap[key] || p.color || '#66c0f4';
        return {
          label: p.displayName || p.fallbackName,
          data: dataValues,
          realValues,
          backgroundColor: hexToRgba(color, 0.35),
          borderColor: color,
          borderWidth: 2,
          hoverBackgroundColor: hexToRgba(color, 0.6),
          hoverBorderColor: color,
          hoverBorderWidth: 3,
          barPercentage: barScale,
          categoryPercentage: barScale,
          maxBarThickness: Math.max(6, 22 - playerCount),
          avatarUrl: p.avatarUrl,
        };
      });

      if (chart) {
        chart.data.labels = metrics;
        chart.data.datasets = datasets;
        chart.options.scales.y.suggestedMax = maxValue ? maxValue * headroomFactor : undefined;
        chart.options.scales.y.grace = '70%';
        chart.options.layout.padding.top = labelPaddingTop;
        chart.options.onClick = (event, elements, chartInstance) =>
          handleChartClick(event, chartInstance);
        chart.update();
        renderStatHeaderButtons(chart);
        return;
      }

      const barValuePlugin = {
        id: 'barValuePlugin',
        afterDatasetsDraw(chart) {
          const { ctx, chartArea } = chart;
          const font = { size: 12, weight: '700', family: 'Segoe UI' };
          const placedByIndex = new Map();
          chart.data.datasets.forEach((dataset, i) => {
            const meta = chart.getDatasetMeta(i);
            meta.data.forEach((bar, index) => {
            const real = dataset.realValues ? dataset.realValues[index] : dataset.data[index];
            const label = formatNumber(real ?? 0);
            const props = bar.getProps(['y', 'base'], true);
            const topY = Math.min(props.y, props.base);
            let y = topY - 12;
            let x = bar.x;
            const minY = chartArea ? chartArea.top + 14 : 14;
            const placed = placedByIndex.get(index) || [];
            const minGap = 12;
            let guard = 0;
            while (
              placed.some((pt) => Math.abs(pt.y - y) < minGap && Math.abs(pt.x - x) < 10) &&
              guard < 6
            ) {
              const jitter = guard % 2 === 0 ? 10 : -10;
              x = bar.x + jitter;
              if (guard > 1) y -= 6;
              guard += 1;
            }
            if (y < minY) y = minY;
            placed.push({ x, y });
            placedByIndex.set(index, placed);
            ctx.save();
            ctx.font = font.weight + ' ' + font.size + 'px ' + font.family;
            ctx.fillStyle = dataset.borderColor || '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(label, x, y);
              ctx.restore();
            });
          });
        },
      };

      const bandPlugin = {
        id: 'bandPlugin',
        beforeDatasetsDraw(chart) {
          const { ctx, chartArea, scales: { x } } = chart;
          if (!x || !chartArea) return;
          const labels = chart.data.labels || [];
          if (labels.length === 0) return;
          ctx.save();
          const height = chartArea.bottom - chartArea.top;
          const colors = ['rgba(255,255,255,0.03)', 'rgba(255,255,255,0.07)'];
          for (let i = 0; i < labels.length; i++) {
            const curr = x.getPixelForTick(i);
            const prev = i > 0 ? x.getPixelForTick(i - 1) : curr - (x.getPixelForTick(Math.min(i + 1, labels.length - 1)) - curr);
            const next = i < labels.length - 1 ? x.getPixelForTick(i + 1) : curr + (curr - prev);
            const left = (curr + prev) / 2;
            const right = (curr + next) / 2;
            const isSelected = userSelectedMetric && selectedMetric && labels[i] === selectedMetric;
            ctx.fillStyle = isSelected ? 'rgba(102,192,244,0.22)' : colors[i % 2];
            ctx.fillRect(left, chartArea.top, right - left, height);
          }
          ctx.restore();
        },
      };

      chart = new Chart(chartCtx, {
        type: 'bar',
        data: { labels: metrics, datasets },
        options: {
          maintainAspectRatio: false,
          responsive: true,
          onClick: (event, elements, chartInstance) => handleChartClick(event, chartInstance),
          scales: {
            x: {
              stacked: false,
              grid: { display: false },
          ticks: {
            display: false,
          },
        },
            y: {
              type: 'logarithmic',
              min: 0.1,
              ticks: { callback: () => '' },
              grid: { display: false },
          grace: '70%', // more headroom so tallest bars leave room for labels
              suggestedMax: maxValue ? maxValue * headroomFactor : undefined,
            },
          },
        layout: { padding: { top: labelPaddingTop } }, // add top padding for label clearance without touching bars
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: false,
              external: externalTooltipHandler,
            },
            zoom: {
              pan: { enabled: true, mode: 'xy' },
              zoom: {
                wheel: { enabled: true, modifierKey: 'ctrl' },
                pinch: { enabled: true },
                drag: { enabled: false },
                mode: 'xy',
              },
            },
          },
        },
        plugins: [bandPlugin, barValuePlugin],
      });

      renderStatHeaderButtons(chart);

      // Hide tooltip when not hovering the chart.
      chartCtx.canvas.addEventListener('mouseleave', () => {
        const el = document.getElementById('chartjs-external-tooltip');
        if (el) el.style.opacity = '0';
      });
    }

    function handleChartClick(event, chartInstance) {
      if (!lastData || !chartInstance) return;
      const { chartArea, scales } = chartInstance;
      const xScale = scales?.x;
      if (!xScale || !chartArea) return;
      const x = event.x;
      const y = event.y;
      if (x == null || y == null) return;
      if (x < chartArea.left || x > chartArea.right || y > chartArea.bottom || y < chartArea.top - 30) {
        return;
      }
      const value = xScale.getValueForPixel(x);
      const index = Math.round(value);
      const labels = chartInstance.data.labels || [];
      if (index < 0 || index >= labels.length) return;
      selectedMetric = labels[index];
      userSelectedMetric = true;
      const colorMap = buildColorMap(lastData.profiles || []);
      renderStatDetails(selectedMetric, lastData, colorMap);
      renderStatHeaderButtons(chartInstance);
      chartInstance.update();
    }

    function setLoading(isLoading, message = 'Loading...') {
      const overlay = document.getElementById('loading-overlay');
      const text = document.getElementById('loading-text');
      const subtext = document.getElementById('loading-subtext');
      if (!overlay || !text || !subtext) return;
      text.textContent = message;
      subtext.textContent = '';
      overlay.classList.toggle('show', !!isLoading);
    }

    function setRefreshStatus(message) {
      const overlayText = document.getElementById('loading-text');
      const overlaySubtext = document.getElementById('loading-subtext');
      if (overlayText && overlaySubtext) {
        overlayText.textContent = 'Loading...';
        overlaySubtext.textContent = message || '';
      }
    }

    function renderPlayers(profiles, colorMap = {}) {
      const container = document.getElementById('players');
      container.innerHTML = profiles
        .map(
          (p) => `
          <div class="player-card" data-player-id="${p.playerId ?? ''}" style="border-color:${hexToRgba(colorMap[p.displayName || p.fallbackName] || p.color || '#66c0f4', 0.35)}; opacity:${p.missing === true ? '0.6' : '1'};">
            <button class="remove-btn" data-steamid="${p.steamId || ''}" data-steamurl="${p.steamUrl || ''}" title="Remove">×</button>
            <a class="player-link" href="${p.steamUrl}" target="_blank" rel="noopener noreferrer">
              <img class="avatar" src="${p.avatarUrl || FALLBACK_AVATAR}" alt="${p.displayName || p.fallbackName} avatar" />
              <div class="player-meta">
                <span class="player-name" style="color:${colorMap[p.displayName || p.fallbackName] || p.color || '#66c0f4'}">${p.displayName || p.fallbackName}</span>
                ${p.missing === true ? '<span class="player-missing">Missing on server</span>' : ''}
              </div>
            </a>
            <button class="player-toggle" title="Edit player">▾</button>
            <div class="player-panel">
              <div class="player-field">
                <label>Steam URL</label>
                <input class="player-steam-url" type="text" value="${p.storedSteamUrl || p.steamUrl || ''}" />
              </div>
              <div class="player-field">
                <label>Steam64 ID</label>
                <input class="player-steam-id" type="text" value="${p.storedSteamId || p.steamId || ''}" />
              </div>
              <button class="player-save">Save</button>
            </div>
          </div>`
        )
        .join('');

      container.querySelectorAll('.player-toggle').forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const card = e.currentTarget.closest('.player-card');
          if (card) card.classList.toggle('expanded');
        });
      });

      container.querySelectorAll('.remove-btn').forEach((btn) => {
            btn.addEventListener('click', async (e) => {
              e.stopPropagation();
              const steamId = e.currentTarget.getAttribute('data-steamid');
              const steamUrl = e.currentTarget.getAttribute('data-steamurl');
              if (!steamId && !steamUrl) return;
              try {
                setLoading(true, 'Removing player...');
                const target = encodeURIComponent(steamId || 'unknown');
                const urlParam = steamUrl ? '?steamUrl=' + encodeURIComponent(steamUrl) : '';
                const resp = await fetch('/api/players/' + target + urlParam, { method: 'DELETE' });
                if (!resp.ok) {
                  const err = await resp.json();
                  alert(err.error || 'Cannot remove');
                  return;
                }
                await refreshData();
              } catch (err) {
                alert('Error removing player');
              } finally {
                setLoading(false);
              }
            });
          });

      container.querySelectorAll('.player-save').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const card = e.currentTarget.closest('.player-card');
          const id = card ? card.getAttribute('data-player-id') : null;
          if (!id) {
            alert('Player id missing. Refresh and try again.');
            return;
          }
          const urlInput = card.querySelector('.player-steam-url');
          const idInput = card.querySelector('.player-steam-id');
          const steamUrl = urlInput ? urlInput.value.trim() : '';
          const steamId = idInput ? idInput.value.trim() : '';
          if (!steamUrl && !steamId) {
            alert('Enter a Steam URL or Steam64 ID.');
            return;
          }
          try {
            setLoading(true, 'Saving player...');
            const resp = await fetch('/api/players/' + encodeURIComponent(id), {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ steamUrl, steamId }),
            });
            if (!resp.ok) {
              const err = await resp.json();
              alert(err.error || 'Save failed');
              return;
            }
            await refreshData();
          } catch (err) {
            alert('Error saving player');
          } finally {
            setLoading(false);
          }
        });
      });
    }

    async function refreshData() {
      document.getElementById('subtitle').textContent = 'Loading...';
      const serverName = serverSelect ? serverSelect.value : 'US Monthly (Premium)';
      setLoading(true, 'Loading...');
      setRefreshStatus('Starting refresh...');
      let statusInterval = null;
      try {
        statusInterval = setInterval(async () => {
          try {
            const resp = await fetch('/api/refresh-status');
            if (resp.ok) {
              const data = await resp.json();
              setRefreshStatus(data.message || '');
            }
          } catch {
            // ignore status errors
          }
        }, 1000);
        const resp = await fetch('/api/refresh', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ serverName }),
        });
        if (!resp.ok) {
          const err = await resp.json();
          throw new Error(err.error || 'Refresh failed');
        }
        const data = await resp.json();
        lastData = data;
        applyRender(data);
        setRefreshStatus('Refresh complete.');
      } catch (err) {
        document.getElementById('subtitle').textContent = err.message;
        setRefreshStatus(err.message);
        try {
          const resp = await fetch('/api/players');
          if (resp.ok) {
            const players = await resp.json();
            const fallbackProfiles = players.map((p) => ({
              steamUrl: p.steamUrl,
              steamId: p.steamId,
              displayName: p.displayName || p.steamId || p.steamUrl,
              fallbackName: p.displayName || p.steamId || p.steamUrl,
              avatarUrl: p.avatarUrl || FALLBACK_AVATAR,
              color: '#66c0f4',
              missing: true,
              playerId: p.id,
              storedSteamUrl: p.steamUrl,
              storedSteamId: p.steamId,
            }));
            renderPlayers(fallbackProfiles, buildColorMap(fallbackProfiles));
          }
        } catch {
          // ignore fallback errors
        }
      } finally {
        if (statusInterval) clearInterval(statusInterval);
        setLoading(false);
      }
    }

    document.getElementById('add').addEventListener('click', async () => {
      const url = prompt('Enter Steam profile URL (id or profiles link)');
      if (!url) return;
      try {
        setLoading(true, 'Adding player...');
        const resp = await fetch('/api/players', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ steamUrl: url }),
        });
        if (!resp.ok) {
          const err = await resp.json();
          alert(err.error || 'Add failed');
          return;
        }
        await refreshData();
      } catch (err) {
        alert('Error adding player');
      } finally {
        setLoading(false);
      }
    });

    document.getElementById('refresh').addEventListener('click', refreshData);

    if (serverSelect) {
      const saved = localStorage.getItem('mooseServerName');
      if (saved && Array.from(serverSelect.options).some((opt) => opt.value === saved)) {
        serverSelect.value = saved;
      }
      serverSelect.addEventListener('change', () => {
        localStorage.setItem('mooseServerName', serverSelect.value);
        refreshData();
      });
    }

    function updateColorToggle() {
      if (!colorToggle) return;
      colorToggle.querySelectorAll('button').forEach((btn) => {
        const isActive = btn.getAttribute('data-mode') === colorMode;
        btn.classList.toggle('active', isActive);
      });
    }

    if (colorToggle) {
      updateColorToggle();
      colorToggle.querySelectorAll('button').forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.getAttribute('data-mode');
          if (!mode || mode === colorMode) return;
          colorMode = mode;
          localStorage.setItem('mooseColorMode', colorMode);
          updateColorToggle();
          if (lastData) {
            applyRender(lastData);
            if (selectedMetric) {
              const colorMap = buildColorMap(lastData.profiles || []);
              renderStatDetails(selectedMetric, lastData, colorMap);
            }
          }
        });
      });
    }

    function hexToRgba(hex, alpha) {
      if (!hex) return `rgba(102,192,244,${alpha})`;
      const clean = hex.replace('#', '');
      const expanded = clean.length === 3 ? clean.split('').map((c) => c + c).join('') : clean;
      const bigint = parseInt(expanded, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    refreshData();
  </script>
</body>
</html>
